#+Title: Putting the Blocks Together
#+Author: James Henderson - Likely
#+Email: james@jarohen.me.uk

#+REVEAL_THEME: night
#+REVEAL_EXTRA_CSS: css/main.css
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_center:nil
#+REVEAL_TRANS: fade

* What to expect?

*Setting up a CLJS project*

*All Mod Cons*

*Experiences and UI Patterns*

*Putting the Blocks Together!*

* 
:PROPERTIES:
:reveal_background: ./img/cat.jpeg
:reveal_background_trans: slide
:END:

* What do we need for a CLJS project?

- Web server (ring/http-kit)
  - Serving page frame and compiled JS

#+ATTR_REVEAL: :frag roll-in
- nREPL
  - Make changes to the running web-app

#+ATTR_REVEAL: :frag roll-in
- lein-cljsbuild
  - Re-compiles CLJS when the files change

* SPLAT - A Lein template

#+begin_src sh
lein new splat <your-project>
cd <your-project>
lein dev
#+end_src

- [[http://http-kit.org][http-kit]] web server
- Basic handlers
- 'Hello world from ClojureScript'
- CLJ/CLJS REPL (provided by [[https://github.com/cemerick/austin][Austin]] + [[https://github.com/james-henderson/lein-frodo][lein-frodo]])
- `lein dev` alias for cljsbuild auto-compilation + web server

#+ATTR_REVEAL: :frag roll-in
We need this for most CLJS projects, hence the template!

* 
# DEMO - Hello world in ClojureScript

* All Mod Cons - REPL

How does a CLJS REPL work?

#+BEGIN_SRC clojure
(loop []
  ;; Browser told to request an HTTP route
  ;; Response contains JS to execute
  ;; Browser sends result in next request, waits for next command
  (recur))
#+END_SRC 

* So, we need:

- Some nREPL middleware to provide the CLJS REPL
- A JS snippet in page-frame to connect to the CLJS REPL
- To start the CLJS REPL

#+ATTR_REVEAL: :frag roll-in
Again, we need this for most CLJS projects, so 'lein-frodo' plugin will set these up.

* Main Differences from Clojure

Function invocation

#+begin_src clojure
(.log js/console "Hello world!")
(js/console.log "Hello world!")
#+end_src

Field access

#+begin_src clojure
(.-body js/document)
(set! (.-hash js/location) "#/")
#+end_src

No Refs/Agents/STM

Must split out requires into ':require' and ':require-macros'

#+begin_src clojure
(ns your.namespace
  (:require [cljs.core.async :as a])
  (:require-macros [cljs.core.async.macros :refer [go go-loop]]))
#+end_src
  

* 
# DEMO - REPL

* Experiences and UI Patterns

/*Caveats*/

None of the theory behind these patterns is new! 

I'll be showing how I've applied some existing UI development best
practices in ClojureScript

These are patterns that I've found myself settling into after having
implemented a variety of different webapps

ClojureScript is still (relatively) new and I'm very much still
learning - any advice/feedback gratefully received!

