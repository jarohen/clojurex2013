#+Title: Putting the Blocks Together
#+Author: James Henderson - Likely
#+Email: james@jarohen.me.uk

#+REVEAL_THEME: night
#+REVEAL_EXTRA_CSS: css/main.css
#+OPTIONS: num:nil toc:nil reveal_history:t reveal_center:nil
#+REVEAL_TRANS: fade

* What's coming up?

*Setting up a CLJS project*

*All Mod Cons*

*Experiences and UI Patterns*

*Putting the Blocks Together!*

** 
:PROPERTIES:
:reveal_background: ./img/cat.jpeg
:reveal_background_trans: slide
:END:

* Setting up a CLJS project

- Web server (ring/http-kit)
  - Serving page frame and compiled JS

#+ATTR_REVEAL: :frag roll-in
- nREPL
  - Make changes to the running web-app

#+ATTR_REVEAL: :frag roll-in
- lein-cljsbuild
  - Re-compiles CLJS when the files change

** SPLAT - A Lein template

#+begin_src sh
lein new splat <your-project>
cd <your-project>
lein dev
#+end_src

- [[http://http-kit.org][http-kit]] web server
- Basic handlers
- 'Hello world from ClojureScript'
- CLJ/CLJS REPL (provided by [[https://github.com/cemerick/austin][Austin]] + [[https://github.com/james-henderson/lein-frodo][lein-frodo]])
- `lein dev` alias for cljsbuild auto-compilation + web server

#+ATTR_REVEAL: :frag roll-in
We need this for most CLJS projects, hence the template!

** 
# DEMO - Hello world in ClojureScript

* All Mod Cons

*Getting to the same toolset and development practices that we take for granted in Clojure*

** All Mod Cons - REPL

How does a CLJS REPL work?

#+BEGIN_SRC clojure
(loop []
  ;; Browser told to request an HTTP route
  ;; Response contains JS to execute
  ;; Browser sends result in next request, waits for next command
  (recur))
#+END_SRC 

*** So, we need:

- Some nREPL middleware to provide the CLJS REPL
- A JS snippet in page-frame to connect to the CLJS REPL
- To start the CLJS REPL

#+ATTR_REVEAL: :frag roll-in
Again, we need this for most CLJS projects, so 'lein-frodo' plugin will set these up.

*** Main Differences from Clojure

Function invocation

#+begin_src clojure
(.log js/console "Hello world!")
(js/console.log "Hello world!")
#+end_src

Field access

#+begin_src clojure
(.-body js/document)
(set! (.-hash js/location) "#/")
#+end_src

No Refs/Agents/STM

Must split out requires into ':require' and ':require-macros'

#+begin_src clojure
(ns your.namespace
  (:require [cljs.core.async :as a])
  (:require-macros [cljs.core.async.macros :refer [go go-loop]]))
#+end_src
  

*** 
# DEMO - REPL

* Experiences and UI Patterns

/*Caveats*/

None of the theory behind these patterns is new! 

I'll be showing how I've applied some existing UI development best
practices in ClojureScript

These are patterns that I've found myself settling into after having
implemented a variety of different webapps

ClojureScript is still (relatively) new and I'm very much still
learning - any advice/feedback gratefully received!

** Patterns

- Widgets + Models
- Widget binding: decoupling appearance from behaviour
- Chord: Servers that look like any other channels

* Of Widgets and Models

# Diagram of widgets + models

** An example widget

#+begin_src clojure
(defn make-board-widget [!model command-ch]
  (def !test-model !model)
  (def test-command-ch command-ch)

  ;; returns a wired-up DOM element that can 
  ;; be added to the page

  (doto (canvas-node)
    (watch-model! !model)
    (listen-for-keypresses! command-ch)))
#+end_src

** An example model

#+begin_src clojure
(defn wire-up-model! [!model command-ch]
  (def !test-model !model)
  (def test-command-ch command-ch)

  (doto !test-model
    (reset! (new-game))
    (repeatedly-tick!)
    (apply-commands! command-ch)))
#+end_src

** Wiring them up:

#+begin_src clojure
(set! (.-onload js/document)
  (fn []
    (let [!model (atom {})
          command-ch (a/chan)]

      (d/replace-contents! (sel1 :#content)
        (node (make-board-widget !model command-ch)))

      (wire-up-model! !model command-ch))))
#+end_src

* Binding - splitting appearance and behaviour
